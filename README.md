## 欢迎来到 知行合壹教育 

查看 [知行合壹教育官网](http://www.zxyi.cn)
# 前端面试题

## HTML部分

## CSS 

### 1.transform、translate、transition 分别是什么属性？CSS 中常用的实现动画方式

> 三者属性说明
> `transform` 是指**变换**、**变形**，是 css3 的一个属性，和 `width`，`height` 属性一样；
> `translate` 是 `transform` 的属性值，是指元素进行 **2D(3D)**维度上位移或范围变换;
> `transition` 是指过渡效果，往往理解成简单的动画，需要有触发条件。
> 这里可以补充下 `transition` 和 `animation` 的比较，前者一般定义开始结束两个状态，需要有触发	条件；而后者引入了关键帧、速度曲线、播放次数等概念，更符合动画的定义，且无需触发条件

### 2.盒子模型
>盒子模型由四大块组成：**外边距** `margin`+**边框** `border` +**内边距** `padding`+**内容** `content`
>
>如果解决外边距**合并塌陷**有三种：
>
>1. 给父元素定议`border`
>
>2. 给父元素定义`padding`
>
>3. 给父元素添加`overflow:hidden`
>
>   

### 3.什么是语义化的HTML？
> 1. 用正确的标签做正确的事情。
> 2. `html`语义化让页面的内容结构化，结构更清晰，便于对浏览器，搜索引擎解析；
> 3. 即使在没有样式`CSS`情况下也以一种文档格式显示，并且是容易阅读的；
> 4. 搜索引擎的爬虫也依赖于HTML标记确定上下文和各个关键字的权重，利用SEO;
> 5. 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

### 4.清除浮动有哪些方式？比较好的方式是哪一种?
> 1. 添加额外标签（隔墙法）`clear：both` 
> 2. 给父元素添加 `overflow:hidden`
> 3. `after`伪元素+`zoom`
> 4. `before`和`after` 双伪元素

### 5.PX、EM、REM的区别？
>1. **px像素**。绝对单位，像素px是相对于显示器屏幕分辨率而言的，是一个虚拟单位。是计算机系统的数字化图像长度单位，如果`px`要换算成物理长度，需要指定精度DPI。
>2. `em`是**相对长度单位**，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。
>3. `rem`是`CSS3`新增的一个**相对单位**(`root` `em`,根`em`),使用`rem`为元素设定字体大小事，仍然是相对大小但相对的只是HTML根元素。
>4. **区别**：IE无法调用那些使用px作为单位的字体大小，而`em`和`rem`可以缩放，`rem`相对的只是`HTML`根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器已支持rem。

### 6.四种定位的区别
>1. `static` 是默认值
>2. `relative` 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中
>3. `absolute` 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指 `position`不是 `static`的元素)祖先元素, 以最的祖先元素为参考标准。如果无已定位祖先元素, 以 `body`元素为偏移参照基准, 完全脱离了标准文档流。
>4. `fixed` 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。

### 7. 请简述CSS样式表继承
>CSS样式表继承指的是，特定的CSS属性向下传递到子孙元素。会被继承下去的属性如下：  
>文本相关：`font-family`，`font-size`， `font-style`，`font-variant`，`font-weight`， `font`，`letter-spacing`，`line-height`，`color`  
>列表相关：`list-style-image`，`list-style-position`，`list-style-type`， `list-style`

### 8. CSS伪类与CSS伪对象的区别

>`CSS` 引入伪类和伪元素的概念是为了描述一些现有CSS无法描述的东西
>根本区别在于：**它们是否创造了新的元素（抽象）**
>**伪类**：一开始用来表示一些元素的动态状态，随后CSS2标准扩展了其概念范围，使其成为了所有逻辑上存在但在文档树中却无须标识的“幽灵”分类
>**伪对象**：代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中

### 9. position的absolute与fixed共同点与不同点

>**相同**：
> a. 改变行内元素的呈现方式，`display`被置为`block`
> b. 让元素脱离普通流，不占据空间
> c. 默认会**覆盖**到非定位元素上
>
> **区别**：
> `absolute`的”**根元素**“是可以设置的，而`fixed`的”根元素“固定为浏览器窗口。
> 当你滚动网页，`fixed`元素与浏览器窗口之间的距离是不变的。

### 10. position的值， relative和absolute分别是相对于谁进行定位的？

>**`absolute`**：生成绝对定位的元素，相对于 `static` 定位以外的第一个祖先元素进行定位
>**`fixed`**：生成绝对定位的元素，相对于浏览器窗口进行定位。 （IE6不支持）
>**`relative`**：生成相对定位的元素，相对于其在普通流中的位置进行定位
>**`static`**：默认值。没有定位，元素出现在正常的流中

### 11. CSS3有哪些新特性？
>CSS3实现**圆角**（`border-radius`），**阴影**（`box-shadow`），对文字加特效（text-shadow），线性>渐变（`gradient`），**变形**（`transform`）
>增加了更多的CSS选择器 多背景 `rgba`，在CSS3中唯一引入的伪元素是`::selection`，媒体查询，多栏布局

### 12. line-height三种赋值方式有何区别？（带单位、纯数字、百分比）

>**带单位**：`px`不用计算，`em`则会使元素以其父元素`font-size`值为参考来计算自己的行高
>**纯数字**：把比例传递给后代，例如父级行高为1.5，子元素字体为18px，则子元素行高为1.5*18=27px
>**百分比**：将计算后的值传递给后代

###  13. :link、:visited、:hover、:active的执行顺序是怎么样的？
>L-V-H-A:
>
>l(`link`)ov(`visited`)e 
>
>h(`hover`)a(`active`)te，
>
>即用喜欢和讨厌两个词来概括



### 14. CSS优先级算法如何计算？
>元素选择符： 1
>`class`选择符： 10
>`id`选择符：100
>元素标签：1000
>`!important`声明的样式优先级最高，如果冲突再进行计算。
>如果优先级相同，则选择最后出现的样式。
>继承得到的样式的优先级最低。

###  15. CSS3新增伪类有那些?
>p:`first-of-type` 选择属于其父元素的**首个**元素
>p:`last-of-type` 选择属于其父元素的**最后**元素
>p:`only-of-type` 选择属于其父元素**唯一**的元素
>p:`only-child` 选择属于其父元素的唯一子元素
>p:`nth-child(2)` 选择属于其父元素的第二个子元素

### 16. 你对line-height是如何理解的？
>行高是指**一行文字的高度**，具体说是两行文字间基线的距离。
>CSS中起高度作用的是`height`和`line-height`，没有定义`height`属性，最终其表现作用一定是`line-height`。
>**单行文本垂直居中**：把`line-height`值设置为`height`一样大小的值可以实现单行文字的垂直居中，其实也可以把`height`删除。
>**多行文本垂直居中**：需要设置`display`属性为`inline-block`。

### 17.  ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用
>单冒号`(:)`用于CSS3**伪类**，双冒号`(::)`用于CSS3**伪元素**。
>`::before`就是以一个**子元素**的存在，定义在元素主体内容之前的一个伪元素。并不存在于`dom`之中，只存在在页面之中。
>`:before` 和 `:after` 这两个**伪元素**，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为`::before` `::after`

### 18. input和textarea的区别
>`input` **是单行文本框**，不会换行。通过size属性指定显示字符的长度，注意：当使	用css限定了宽高，那么`size`属性就不再起作用。**`value`属性指定初始值**，`Maxlength`属	性指定文本框可以输入的最长长度。可以通过`width`和`height`设置宽高，但是也不会增	加行数。
>
> `textarea`  是**多行文本输入框**，文本区中可容纳无限数量的文本，**无`value`属性**，其中	的文本的默认字体是等宽字体（通常是   `Courier`） ，可以通 过 `cols` 和 `rows` 属性来规	定 `textarea` 的尺寸，不过更好的办法是使用 CSS 的 `height` 和 `width` 属性。

### 19. css三大特性
>**层叠性**：层叠性是指当一个标签被设置了多个重复的样式的时候，一个属性会覆盖另外	一个属性
>**继承性**：继承性是指当子标签没有设置样式时，会继承父标签的样式。
>**优先级**：`!important`>行内样式>id选择器>类选择器>标签选择器>通配符>继承

### 20. 选择器
>**基础选择器**：标签选择器、类名选择器、id 选择器、通配符选择器
>**复合选择器**：子代选择器、后代选择器、交集选择器、并集选择器、伪元素选择器、	  伪类选择器、属性选择器、链接伪类选择器

### 21. 相邻的两个inline-block节点为什么会出现间隔，该如何	解决
>`Inline-block`:一个格式化为行内元素的**块级容器**
>因为**西文排版**的问题，英文有空格作为词分界，而中文则没有。
>**方法一**：给父级元素设置`font-size： 0`；子元素设置相应的`font-size`
>**方法二**：改变书写方式，元素间留白间距出现的原因就是标签段之间的空格，因此，去	掉HTML中的空格，自然间距就消失了
>**方法三**：`margin`负值的大小与上下文的字体和文字大小相关，Arial字体的`margin`负值	为-3像素，`Tahoma`和`Verdana`就是-4像素，而`Geneva`为-6像素。由于外部环境的不	确定性，以及最后一个元素多出的父`margin`值等问题，这个方法不适合大规模使用。
>
>**方法四**：设置父元素，`display:table`和`word-spacing`

### 22. Meta viewport 移动端适配
>  `layout viewport` :是浏览器设置的显示大小，由浏览器厂商决定，一般为980px;这个宽度可以使用
>
>  ```js
>  document.documentElement.clientWidth 来获取。
>  ```
>
>
>  `visual viewport` :浏览器可视区域的大小，一般`layout viweport` 都会大于浏览器可视区	域。	可以使用`ducument.documentElement.innerWidth`来获取。
>  `ideal viewport` :是用户设置的大小，由标签
>
>  ```js
>  <meta name="viewport">决定
>  ```
>
>  移动设备默认的`ideal viweport`是 
>
>  ```js
>  layout viewport（content="width=device-width）
>  ```

### 23. rem 布局的优缺点

> **优点**：理想状态是所有屏幕的高宽比和最初的设计高宽比一样，或者相差不多，完美适应
>
> **缺点**：碰到重视高度的设计，或者重视元素间间距的设计。

### 24. 1像素的问题
>物理像素：不同屏幕的像素点不一样
>逻辑像素：CSS 里的1px
>设备像素 
>设备像素=物理像素/逻辑像素 
>了解设备物理像素和逻辑像素的同学应该很容易理解，其实这两个px的含义其实是不一样的，UI设计师要求的1px是指设备的物理像素1px，而CSS里记录的像素是逻辑像素，它们之间存在一个比例关系

### 25. 用一个 div 模拟 textarea的实现

>1、内容可编辑 contenteditable
>
> 对就是contenteditable，给div添加contenteditable=true即可；
>
>2、demo
>
>```js
>//css
>div{
>    width: 400px;
>    min-height: 100px;
>    max-height: 300px;
>    _height: 100px; //IE6
>    margin-left: auto;
>    margin-right: auto;
>    padding: 3px;
>    outline: 0;
>    border: 1px solid #a0b3d6;
>    font-size: 12px;
>    word-wrap: break-word;
>    overflow-x: hidden;
>    overflow-y: auto; //超过最大高度就出现滚动条
>    _overflow-y: visible;
>}
> 
>//html
><div contenteditable="true">
>    .....此处省略.....
></div>
>```

### 26. css 实现宽度自适应100%，宽高比16：9的比例的矩形
>**第一步**：先计算高度，假设宽100%，那么高为h=9/16=56.25%
>**第二步**：利用之前所说设置`padding-bottom`方法实现矩形

### 27. bfc实现清除浮动

>BFC（块级格式化上下文），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题
>
>BFC是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用

### 28. HTML常见兼容性问题？
>1. 双边距BUG `float`引起的  使用`display`
>
>2. 3像素问题 使用float引起的 使用`dislpay:inline -3px`
>
>3. 超链接hover 点击后失效  使用正确的书写顺序 `link` `visited` `hover` `active`
>
>4. Iez-index问题 给父级添加`position:relative`
>
>5. Png透明 使用js代码改
>
>6. Min-height最小高度 `!Important`解决’
>
>7. `select`在ie6下遮盖使用`iframe`嵌套
>
>8. 为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的
>
>   ```js
>   使用over:hidden,zoom:0.08line-height:1px
>   ```
>
>   )
>
>9. IE5-8不支持`opacity`，解决办法：
>
>  ```js
>  .opacity{
>  opacity: 0.4
>  filter: alpha(opacity=60); /* for IE5-7 */
>  -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=60)"; /* for IE 8*/
>  }
>  ```
>
>10. IE6不支持PNG透明背景，解决办法: IE6下使用gif图片

### 29. rgba() 和 opacity 设置透明度的区别是什么？

> `rgba()`和`opacity`都能实现透明效果，但最大的不同是`opacity`作用于元素，以及元素内的所有内容的透明度，而`rgba()`只作用于元素的颜色或其背景色。（设置`rgba`透明的元素的子元素不会继承透明效果！）

### 30. DOCTYPE的作用

>1. `<!DOCTYPE>` 声明位于文档中的最前面，处于 `<html>` 标签之前。告知浏览器以何种模式来渲染文档。
>1. 严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。
>2. 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站
点无法工作。
>1. `DOCTYPE` 不存在或格式不正确会导致文档以混杂模式呈现。

### 32.请描述一下cookies]()，sessionStorage和localStorage的区别？

>- sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
>
>- Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
>
>- 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。

## JS-基础

### 1.判断 js数据 类型的方式

> 1. **typeof**
> 可以判断出'`string`','`number`','`boolean`','`undefined`','`symbol`'
> 但判断 `typeof(null)` 时值为 '`object`'; 判断数组和对象时值均为 '`object`'
> 2. **instanceof**
> 原理是 构造函数的 `prototype` 属性是否出现在对象的原型链中的任何位置
> ```js
> function A() {
>   
> }
> let a = new A();
> a instanceof A     //true,因为 Object.getPrototypeOf(a) === A.prototype;
> ```
> 3. **Object.prototype.toString.call()**
> 常用于判断浏览器内置对象,对于所有基本的数据类型都能进行判断，即使是 `null` 和 `undefined`
> 4. **Array.isArray()**用于判断是否为数组

### 2.ES5 和 ES6 分别几种方式声明变量

> ES5 有俩种：`var` 和 `function`
> ES6 有六种：增加四种，`let`、`const`、`class` 和 `import`
>
> 注意：`let`、`const`、`class`声明的全局变量再也不会和全局对象的属性挂钩

### 3.解释什么是浅拷贝和深拷贝，如何实现对复杂数据类型的深拷贝?

>浅拷贝
>// 第一层为深拷贝`Object.assign()Array.prototype.slice()`
>扩展运算符 ...
>深拷贝`JSON.parse(JSON.stringify())`

### 4.数组去重的方法

> 1**.ES6 的 Set**
>
> ```js 
> let arr = [1,1,2,3,4,5,5,6]
> let arr2 = [...new Set(arr)]
> ```
>
> 2**.reduce()**
>
> ```js  
> let arr = [1,1,2,3,4,5,5,6]
> let arr2 = arr.reduce(function(ar,cur) {
> 	if(!ar.includes(cur)) {
> 	 	ar.push(cur)
> 		}
> 		return ar
> },[])
> ```
>
> 3.**filter()**
>
> 这种方法会有一个问题：[1,'1']会被当做相同元素，最终输入
>
> ```js [1]let arr = [1,1,2,3,4,5,5,6]
> let arr2 = arr.filter(function(item,index) {
> 	// indexOf() 方法可返回某个指定的 字符串值 在字符串中首次出现的位置
> 	return arr.indexOf(item) === index
> })
> ```

### 5.DOM 事件有哪些阶段？谈谈对事件代理的理解

> 分为三大阶段：**捕获阶段--目标阶段--冒泡阶段**
>
> 事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操	作时(例如'click')，再通过条件判断，执行事件触发后的语句(例如'`alert(e.target.innerHTML)'`)
> **好处：**
>
> (1)使代码更简洁；
>
> (2)节省内存开销

### 6.ES6 的 class 和构造函数的区别
> `class` 的写法只是语法糖，和之前 `prototype` 差不多，但还是有细微差别的，下面看看：
>
> 1. 严格模式
> 	类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写	在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 	实际上把整个语言升级到了严格模式。
> 	
> 2. 不存在提升
>     类不存在变量提升（hoist），这一点与 ES5 完全不同。
>
>   ```js 
>   new Foo(); // ReferenceErrorclass Foo {}
>   ```
>
> 3. 方法默认是不可枚举的
> 	ES6 中的 `class`，它的方法（包括静态方法和实例方法）默认是不可枚举的，而构造函数默认是可枚	举的。细想一下，这其实是个优化，让你在遍历时候，不需要再判断 `hasOwnProperty` 了
> 	
> 4. `class` 的所有方法（包括静态方法和实例方法）都没有原型对象 `prototype`，所以也没有	`[[construct]]`，不能使用 `new` 来调用。
>
> 5. `class` 必须使用 `new` 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 `new` 	也可以执行。
>
> 6. ES5 和 ES6 子类 `this` 生成顺序不同
> 	ES5 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例。ES6 的继承先 生成父类实例，	再调用子类的构造函数修饰父类实例。这个差别使得 ES6 可以继承内置对象。
> 	
> 7. ES6可以继承静态方法，而构造函数不能

### 7.经典面试题：循环中使用闭包解决`var `定义函数的问题

>**第一种**是利用闭包的方式
>**第二种**就是使用 `setTimeout` 的第三个参数，这个参数会被当成 `timer` 函数的参数传入。
>**第三种**就是使用 `let` 定义 i 了来解决问题了，这个也是最为推荐的方式

### 8.解释一下什么是JS作用域

>作⽤域就是⼀个独⽴的地盘，让变量不会外泄、暴露出去。 只有**全局作⽤域**和**函数作⽤域**
>`js`作用域（**全局作用域** 和 **函数作用域**）内部可以访问外部，但外部的不能访问内部的
>不用`var` 定义变量时，会默认为是**全局变量**（不规范，不推荐）
>变量的查找是就近原则去寻找，定义的`var`变量；

### 9.解释一下什么是 JS作用域链

>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。
>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到**全局作用域**，这么一个查找过程形成的链条就叫做**作用域链**。

### 10.线程与进程的区别

>一个**程序**至少有一个**进程**,一个**进程**至少有一个**线程.** 
>线程的划分尺度小于进程，使得多线程程序的并发性高。 
>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行	效率。 
>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程	序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并	没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的	重要区别

### 11.null和undefined的区别？

>`undefined`是一个表示"无"的原始值，转为数值时为 当声明的变量还未被初始化时，变量的默认值为`null`用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
>（1）变量被声明了，但没有赋值时，就等于`undefined`。
>
> （2)   调用函数时，应该提供的参数没有提供，该参数等于`undefined`。 
>
>（3）对象没有赋值的属性，该属性的值为`undefined`。 
>
>（4）函数没有返回值时，默认返回`undefined`。
>
>（1） 作为函数的参数，表示该函数的参数不是对象。 
>
>（2） 作为对象原型链的终点。

### 12.new操作符具体干了什么呢?

>1、创建一个空对象，并且 `this` 变量引用该对象，同时还继承了该函数的原型。
>2、属性和方法被加入到 `this` 引用的对象中。
>3、新创建的对象由 `this` 所引用，并且最后隐式的返回 this 。 
>
>```js 
>var obj  = {};
>obj.__proto__ = Base.prototype;
>```
>
>

### 13. "==" 和 "===" 的区别？

>通俗的说： == 代表**相同**， ===代表**严格相同**, 为啥这么说呢， 
>
>这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是`false`.

### 14.JS中的常用内置对象有哪些？并列举该对象的常用方法？

> js常用内置对象有：`Arguments` `Array`  `Boolean`  `Error`  `Function` `Math`  `Number`  `Object` `RegExp`  `String`
>
> 1. **Arguments 函数参数集合**
>`arguments[ ]` 函数参数的数组
> `Arguments` 一个函数的参数和其他属性
> `Arguments.callee` 当前正在运行的函数
> `Arguments.length` 传递给函数的参数的个数
> 1. **Array 数组**
> `length`属性 动态获取数组长度
> `join()` 将一个数组转成字符串。返回一个字符串。
> `reverse()` 将数组中各元素颠倒顺序
> `delete`运算符 只能删除数组元素的值，而所占空间还在，总长度没变`(arr.length)`。
> `shift()` 删除数组中第一个元素，返回删除的那个值，并将长度减 1。
> `pop()` 删除数组中最后一个元素，返回删除的那个值，并将长度减1。
> `unshift()` 往数组前面添加一个或多个数组元素，长度要改变。
> `push()` 往数组结尾添加一个或多个数组元素，长度要改变。
> `concat( )` 连接数组
> `slice( )` 返回数组的一部分
> `sort( )` 对数组元素进行排序
> `splice( )` 插入、删除或替换数组的元素
> `toLocaleString( )` 把数组转换成局部字符串
> `toString( )` 将数组转换成一个字符串
>
> 2. **Boolean 布尔对象**
> `Boolean.toString( )` 将布尔值转换成字符串
> `Boolean.valueOf( ) Boolean`对象的布尔值
>
> 3. **Error 异常对象**
> `Error.message` 可以读取的错误消息
> `Error.name` 错误的类型
> `Error.toString`( ) 把Error 对象转换成字符串
> `EvalError` 在不正确使用 eval()时抛出
> `SyntaxError` 抛出该错误用来通知语法错误
> `RangeError` 在数字超出合法范围时抛出
> `ReferenceError` 在读取不存在的变量时抛出
> `TypeError` 当一个值的类型错误时，抛出该异常
> `URIError` 由URl的编码和解码方法抛出
>
> 4. **Function 函数构造器**
> `Function` 函数构造器
> `Function.apply( )` 将函数作为一个对象的方法调用
> `Function.arguments[]` 传递给函数的参数
> `Function.call( )` 将函数作为对象的方法调用
> `Function.caller` 调用当前函数的函数
> `Function.length` 已声明的参数的个数
> `Function.prototype` 对象类的原型
> `Function.toString( )` 把函数转换成字符串
>
> 5. **Math 数学对象**
> `Math`对象是一个静态对象
> `Math.PI` 圆周率。
> `Math.abs()` 绝对值。
> `Math.ceil()` 向上取整(整数加 1，小数去掉)。
> `Math.floor()` 向下取整(直接去掉小数)。
> `Math.round()` 四舍五入。
> `Math.pow(x，y)` 求 x的y次方。
> `Math.sqrt()` 求平方根。
>
> 6. **Number 数值对象**
> `Number.MAX_VALUE` 最大数值
> `Number.MIN_VALUE` 最小数值
> `Number.NaN` 特殊的非数字值
> `Number.NEGATIVE_INFINITY` 负无穷大
> `Number.POSITIVE_INFINITY` 正无穷大
> `Number.toExponential( )` 用指数计数法格式化数字
> `Number.toFixed( )` 采用定点计数法格式化数字
> `Number.toLocaleString( )` 把数字转换成本地格式的字符串
> `Number.toPrecision( )` 格式化数字的有效位
> `Number.toString( )` 将—个数字转换成字符串
> `Number.valueOf( )` 返回原始数值
>
> 7. **Object 基础对象**
> `Object` 含有所有 `JavaScript` 对象的特性的超类
> `Object.constructor` 对象的构造函数
> `Object.hasOwnProperty( )` 检查属性是否被继承
> `Object.isPrototypeOf( )` 一个对象是否是另一个对象的原型
> `Object.propertyIsEnumerable( )` 是否可以通过 `for/in`循环看到属性
> `Object.toLocaleString( )` 返回对象的本地字符串表示
> `Object.toString( )` 定义一个对象的字符串表示
> `Object.valueOf( )` 指定对象的原始值
>
> 8. **RegExp 正则表达式对象**
> `RegExp.exec( )` 通用的匹配模式
> `RegExp.global` 正则表达式是否全局匹配
> `RegExp.ignoreCase` 正则表达式是否区分大小写
> `RegExp.lastIndex` 下次匹配的起始位置
> `RegExp.source` 正则表达式的文本
> `RegExp.test( )` 检测一个字符串是否匹配某个模式
> `RegExp.toString( )` 把正则表达式转换成字符串
>
> 9. **String 字符串对象**
> `Length` 获取字符串的长度。
> `toLowerCase()` 将字符串中的字母转成全小写。
> `toUpperCase()` 将字符串中的字母转成全大写。
> `charAt(index)` 返回指定下标位置的一个字符。如果没有找到，则返回空字符串。
> `substr()` 在原始字符串，返回一个子字符串
> `substring()` 在原始字符串，返回一个子字符串。
> `split()` 将一个字符串转成数组。
> `charCodeAt( )` 返回字符串中的第 n个字符的代码
> `concat( )` 连接字符串
> `fromCharCode( )` 从字符编码创建—个字符串
> `indexOf( )` 返回一个子字符串在原始字符串中的索引值(查找顺序从左往右查找)。如果没 有找到，则返回-1。
> `lastIndexOf( )` 从后向前检索一个字符串
> `localeCompare( )` 用本地特定的顺序来比较两个字符串
> `match( )` 找到一个或多个正则表达式的匹配
> `replace( )` 替换一个与正则表达式匹配的子串
> `search( )` 检索与正则表达式相匹配的子串
> `slice( )` 抽取一个子串
> `toLocaleLowerCase( )` 把字符串转换小写
> `toLocaleUpperCase( )` 将字符串转换成大写
> `toLowerCase( )` 将字符串转换成小写
> `toString( )` 返回字符串
> `toUpperCase( )` 将字符串转换成大写
> `valueOf( )` 返回字符串

### 15.JS中有哪些数据类型？

>简单数据类型：`Undefined`、`Null`、`Boolean`、`Number` 和`String`。
>复杂数据类型：`Object`

### 16. 解释一下什么是原型链？

> `Javascript` 是面向对象的，每个实例对象都有**一个`proto_`属性，该属性指向它原 型对象，这个实例对象的构造函数有一个原型属性 `prototype`，与实例的`proto`属性指 向同一个对象。当一个对象在查找一个属性的时，自身没有就会根据`proto_`** 向它的原型 进行查找，如果都没有，则向它的原型的原型继续查找，直到查到 `Object.prototype.proto_`为`null`，这样也就形成了原型链。

### 17.字符串的常用方法有哪些？

>**`charCodeAt`** 方法返回一个`Unicode`，代表指定位置字符的 `Unicode` 编码；
>**`charAt`**方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串；
>**`slice`**方法返回字符串的片段；
>**`substring`**方法返回位于`String` 对象中指定位置的子字符串。
>**`substr`**方法返回一个从指定位置开始的指定长度的子字符串。
>**`indexOf`**方法返回 `String` 对象内第一次出现子字符串位置。如果没有找到子字符串， 则返回-1；
>**`lastIndexOf`**方法返回 `String`对象中字符串最后出现的位置。如果没有匹配到子字符 串，则返回-1；
>**`search`**方法返回与正则表达式查找内容匹配的第一个字符串的位置。
>**`concat`** 方法返回字符串值，该值包含了两个或多个提供的字符串的连接；
>**`split`** 将一个字符串分割为子字符串，然后将结果作为字符串数组返回；

### 18.DOM节点的增删改查方法？

>1. **创建节点、追加节点**
>`createElement`（标签名）创建一个元素节点（具体的一个元素）。
>`createTextNode`（节点文本内容）创建一个文本节点。
>`createDocumentFragment`() //创建一个 DOM 片段。
>`appendChild`（节点）追加一个节点。
>2. **插入节点**
>`appendChild`（节点）也是一种插入节点的方式，还可以添加已经存在的元素，会将其
>元素从原来的位置移到新的位置。
>`insertBefore（a,b）`是参照节点，意思是 a节点会插入 b节点的前面。
>3. **删除、移除节点**
`removeChild(节点)` 删除一个节点，用于移除删除一个参数（节点）。其返回的被移除
的节点，被移除的节点仍在文档中，只是文档中已没有其位置了。
>4. **复制节点**
>`cloneNode()` 方法，用于复制节点， 接受一个布尔值参数， true 表示深复制（复制节点
>及其所有子节点）， `false` 表示浅复制（复制节点本身，不复制子节点）。
>5. **替换节点**
>`replaceChild`(插入的节点，被替换的节点) ，用于替换节点，接受两个参数，第一参数
>是要插入的节点，第二个是要被替换的节点。返回的是被替换的节点。
>6. **查找节点**
>`getElementsByTagName()` //通过标签名称
>`getElementsByName()` //通过元素的`Name` 属性的值(IE容错能力较强，会得到一
>个数组，其中包括 id等于 name值的)
>`getElementById()` //通过元素 Id，唯一性

### 19.什么是预解析？

>在代码整体执行之前，先解析一部分。
>预解析之后，代码才会从上往下依次整体执行，但是预解析执行过的代码不会 重复执行。
>js预解析干了什么事：`js` 中预解析会把声明部分的代码预先执行。
>声明相关的代码可以分为两部分：
>1、 变量声明 通过 `var`关键字定义的变量。
>2、函数声明 通过 `function`关键字声明的函数
>预解析时如果遇到重复的变量声明，那么忽略。
>预解析时如果遇到重复的函数声明，保留后面的函数。
>预解析时如果遇到变量与函数重名的情况，保留函数。

### 20. 什么是变量名提升？

>使用 `var`关键字定义的变量，被称为变量声明；
>函数声明提升的特点是，在函数声明的前面，可以调用这个函数。

### 21.JS中的typeof关键字能返回哪些数据类型？

>`typeof`一般判断基本数据类型。是一个操作符而不是函数，圆括号可有可无。
>`typeof` 返回值有：`string`，`number`，`boolean`，`undefined`，`object` ，`function`，
>基本数据类型：`Boolean`、`Number`、`String`、`Undefined`、`Null`
>基本数据类型中数字，字符串，布尔类型返回其对类型 `undefined`返回 `undefined`
>九大内置构造函数及其他所有函数返回`function`；
>其他所有复杂类型对象和null返回 `object`

### 22.简述创建函数的几种方式？

>1. 函数声明
>
>  ```js
>  function sum1(num1,num2){
>      return num1+num2;
>  }
>  ```
>
>2. 函数表达式
>
>  ```js
>  var sum2 = function(num1,num2){
>         return num1+num2;
>  }
>  ```
>
>3. 函数对象方式
>
>  ```js
>  var sum3 = new Function("num1","num2","return num1+num2");
>  ```



## JS-高级

### 1.说说你对`this`关键字的理解？
> `this` 是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内 部使用。
> 1.作为纯粹的函数调用 `this` 指向全局对象
> 2.作为对象的方法调用 `this` 指向调用对象
> 3.作为构造函数被调用 `this` 指向新的对象（`new`会改变 `this` 的指向）
> 4.`apply` 调用 `this` 指向 `apply`方法的第一个参数

### 2.请解释一下`JavaScript`的同源策略？如何实现跨域 ？
>- 同源策略在什么情况下会起作用呢？ 当`web` 页面使用多个`<iframe>`元素或者打开其他浏览器窗口的时候，这一策略就 会起作用。
>
>- 同源策略的含义： 脚本只能读取和所属文档来源相同的窗口和文档的属性。 这里就涉及到了一个浏览器如何判断两者是否同源以及如何判断脚本来源的问题。
>
>- 注意一点：脚本本身的来源并不作为判断是否同源的依据，而是将脚本所属文档的来源 作为判断依据。
>
>1. 判断脚本来源 例如：文档 A中通过 `script` 的 `src`引用了一个外部脚本，这个脚本是 google 提供的，也是从google 的主机上加载到文档 A中的，那么这个脚本的所属文档是谁呢， 答案是文档A。
>2. 判断是否同源 理解了脚本来源，接着理解怎么判断是否同源：如果两个文档在协议、主机以 及载入文档的 `URL`端口这三点中有一点不同，就认为他们不同源。

---

> - `JSONP`(`JSON with Padding`填充式`JSON` 或参数式 `JSON`)
> -  在js 中，我们虽然不能直接用`XMLHttpRequest` 请求不同域上的数据，但是在页面上引入不同域上的js 脚本文件却是可以的，`jsonp`正是利用这个特性来实现的。
> - `JSONP` 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的`JSON` 数据。
> - 优点： 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要`XMLHttpRequest` 或 `ActiveX` 的支持； 能够直接访问响应文本，支持在浏览器与服务器之间双向通信
> - 缺点： `JSONP` 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些 恶意代码，而此时除了完全放弃 `JSONP` 调用之外，没有办法追究。因此在使用不是你自己 运维的`Web` 服务时，一定得保证它安全可靠。 它只支持 `GET`请求而不支持 `POST`等其它类型的 `HTTP` 请求；它只支持跨域 `HTTP` 请 求这种情况，不能解决不同域的两个页面之间如何进行 `JavaScript`调用的问题

### 3.`call`和`apply`的区别？举例说明他们的作用！

> - 它们的共同之处：都“可以用来代替另一个对象调用一个方法，将一个函数的对象上 下文从初始的上下文改变为由 `thisObj` 指定的新对象。”
> - 它们的不同之处：
>   - `Apply`：最多只能有两个参数——新`this` 对象和一个数组 `argArray`。如果给该方法传递多 个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里面。如 果 `argArray` 不是一个有效的数组或者不是 `arguments` 对象，那么将导致一个 `TypeError`。如果没有提供 `argArray` 和 `thisObj` 任何一个参数，那么 `Global` 对象将被 用作 `thisObj`， 并且无法被传递任何参数
>   - `Call`：则是直接的参数列表，主要用在`js` 对象各方法互相调用的时候，使当前 `this` 实例指 针保持一致，或在特殊情况下需要改变this指针。如果没有提供 `thisObj` 参数，那么 `Global` 对象被用作 `thisObj`。

### 4.什么是事件的冒泡和捕获？如何开启事件冒泡和捕获？

>- 事件冒泡：子元素事件的触发会影响父元素事件；
>
>- 开关事件冒泡：
>
> - A，开启事件冒泡：
>
>   ```js
>   element.addEventListener(eventName，handler，false)；
>   ```
>
> - B，关闭事件冒泡：假设传统方式事件的返回值为 e，就可以通过 `e.stopPropagation()`来关闭事件冒泡；
>
> - 事件捕获：父元素的事件会影响子元素的事件；
>
> - 开启事件捕获：
>
>   ```js
>   element.addEventListener(eventName，handler，true)
>   ```



### 5.`JavaScript` 中的垃圾回收机制?

> 在`Javascript` 中，如果一个对象不再被引用，那么这个对象就会被`GC` 回收。如 果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。 因为函数 a被b引用，b又被 a外的 c引用，这就是为什么 函数 a 执行后不会被回收的原 因。

### 6.用正则表达式，写出由字母开头，其余由数字、字母、下划线组成的6~30的字符串？

> ```js
> /^[a-zA-Z]{1}[\w]{5,29}$/
> ```



### 7.`Javascript`中`callee`和`caller`的作用？

>- `caller`是返回一个对函数的引用，该函数调用了当前函数；
>
>- `callee`是返回正在被执行的`function`函数，也就是所指定的`function`对象的正文。

### 8.移动端touch事件判断滑屏手势的方向？

> 当开始一个touchstart事件的时候，获取此刻手指的横坐标startX和纵坐标startY；
> 当触发touchmove事件时，在获取此时手指的横坐标moveEndX和纵坐标moveEndY;最后，通过这两次获取的坐标差值来判断手指在手机屏幕上的滑动方向。
> 思路：用touchmove的最后坐标减去touchstart的起始坐标，X的结果如果正数，则说明手指是从左往右划动；X的结果如果负数，则说明手指是从右往左划动；Y的结果如果正数，则说明手指是从上往下划动；Y的结果如果负数，则说明手指是从下往上划动。
>
> 具体代码如下：
>
> ```js
> var mybody = document.getElementsByTagName('body')[0];
> 
> //滑动处理
> var startX, startY, moveEndX, moveEndY, X, Y;
> mybody.addEventListener('touchstart', function(e) {
>    e.preventDefault();
>    startX = e.touches[0].pageX;
>    startY = e.touches[0].pageY;
> });
> mybody.addEventListener('touchmove', function(e) {
>  e.preventDefault();
>    moveEndX = e.changedTouches[0].pageX;
>    moveEndY = e.changedTouches[0].pageY;
>    X = moveEndX - startX;
>    Y = moveEndY - startY;
>  if ( X > 0 ) {alert(‘向右’);}
>    else if ( X < 0 ) {alert(‘向左’);}
>    else if ( Y > 0) {alert(‘向下’);}
>    else if ( Y < 0 ) { alert(‘向上’);}
>    else{alert(‘没滑动’); }
> });
> ```

### 9.`get`和`post`的区别？

> - `GET`：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符
>
> - `POST`：一般用于修改服务器上的资源，对所发送的信息没有限制
>
> - 在以下情况中，请使用 `POST` 请求：
>   - 1. 无法使用缓存文件（更新服务器上的文件或数据库）
>   - 2. 向服务器发送大量数据（`POST` 没有数据量限制）
>   - 3. 发送包含未知字符的用户输入时，`POST` 比`GET` 更稳定也更可靠

### 10.解释`jsonp`的原理？JSONP的优缺点

> `Jsonp`并不是一种数据格式，而`json`是一种数据格式，`jsonp`是用来解决跨域获取数据的一种解决方案，具体是通过动态创建`script`标签，然后通过标签的`src`属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术

---

>  - 优点:  
>
>     它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 `XMLHttpRequest` 或 `ActiveX` 的支持; 
>   能够直接访问响应文本，支持在浏览器与服务器之间双向通信
>
> - 缺点:
>
>     `JSONP` 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些 恶意代码，而此时除了完全放弃 `JSONP` 调用之外，没有办法追究。因此在使用不是你自己 运维的 `Web` 服务时，一定得保证它安全可靠。 
>     它只支持 `GET` 请求而不支持 `POST` 等其它类型的 `HTTP` 请求;它只支持跨域 `HTTP` 请 求这种情况，不能解决不同域的两个页面之间如何进行 `JavaScript` 调用的问题 

### 11.有哪些方式继承？ES6的继承方式？

>1. 借用构造函数。也叫伪造对象或经典继承。 思路：在子类构造函数的内部调用超类型构造函数。可以通过使用 apply()和call()方法 在新创建的对象上执行构造函数。 缺点：方法都在构造函数中定义，函数的复用就无从谈起。在超类型的原型中定义的方 法，对子类而言也是不可见的，结果所有的类型都只能使用构造函数模式。
>2. 组合继承。也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一起， 从而发挥二者之长。 思路：使用原型链实现对原型属性属性和方法的继承，通过借用构造函数来实现实例属 性的继承。 优点：既通过在原型上定义方法实现了函数复用，又能保证每一个实例都有它自己的数 组。 组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，成为 JavaScript 中常用的继承模式。
>3. 原型链继承。 思路：借助原型可以基于已有的对象创建对象，同时还不必因此创建自定义类型。 在object()函数内部，先创建一个临时的构造函数，然后将传入的对象作为这个构造函 数的原型，最后返回了这个临时类型的一个新实例。
>4. 寄生式继承。 思路：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最 后再像真的是它做了所有的工作一样返回对象。缺点：使用寄生式继承来为对象添加函数，会由于不能做到函数复用二降低效率，这一 点和构造函数模式类似。 
>5. 寄生组合式继承。是JavaScript 最常用的继承模式。 思路：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 开发人员普遍认为寄生组合式继承时引用类型最理想的继承范式。 extend（）方法才用了这样的方式。

### 12.怎么防止内存泄露？

>1. 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收
>2. 注意程序逻辑，避免“死循环”之类的
>3. 避免创建过多的对象 。

### 13.HTTP状态码都有哪些？

>100 => 正在初始化（一般是看不到的）
>
>101 => 正在切换协议（`websocket`浏览器提供的）
>
>200或者以2开头的两位数 => 都是代表响应主体的内容已经成功返回了
>
>202 => 表示接受
>
>301 => 永久重定向/永久转移
>
>302 => 临时重定向/临时转移（一般用来做服务器负载均衡）
>
>304 => 本次获取的内容是读取缓存中的数据，会每次去服务器校验
>
>400 => 参数出现错误（客户端传递给服务器端的参数出现错误）
>
>401 => 未认证，没有登录网站
>
>403 => 禁止访问，没有权限
>
>404 => 客户端访问的地址不存在
>
>500 => 未知的服务器错误
>
>503 => 服务器超负荷（假设一台服务器只能承受10000人，当第10001人访问的时候，如果服务器没有做负载均衡，那么这个人的网络状态码就是503）

### 14.简单描述下同步和异步的区别，并举例实际应用中哪些是同步，哪些是异步？

>同步是阻塞的，浏览器向服务器发送请求，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，页面才可以正常显示；
>
>异步是非阻塞的，浏览器向服务器请求数据，服务器比较忙，浏览器可以干自己原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新



### 15. ES6有哪些新特性？

>类的支持，模块化，箭头操作符，let/const块作用域，字符串模板，解构，参数默认值/不定参数/拓展参数, for-of遍历, generator, Map/Set, Promise
>
>个人看法：从软件工程角度来看，以前真的很弱，不适合做大型应用，很容易导致烂尾工程。ES6就相当于当年的Java5,是历史性的发展，从此我们可以用js做大型项目了。事实上，各大主流浏览器现在已经支持大部分新特性了，后端的Node.js更是可以直接使用ES6的绝大多数语法。

### 16.箭头函数的特点以及如何获取箭头函数中传入的所有的实参？

### 17.git的作用是什么，有哪些命令，这些命令的作用是什么？在pull时，如果只想要文件的一部分而不是工程文件的整个，使用什么命令？git的冲突如何解决?

> git是一个开源的分布式版本控制系统，用以有效、高速处理很小到非常大的项目版本管理。
>
> 常用的命令：  `git init`  初始化仓库
>
> `git config --global user.name`   配置用户名
>
> `git config --global user.email`   配置邮箱
>
> `git add `   文件添加到暂存区
>
> `git commit`  文件添加到仓库
>
> `git branch`   列出所有的分支
>
> `git status`   显示有变更的文件
>
> `git log`    查看当前分支的版本历史
>
> `git push`    提交本地代码到远程
>
> `git pull`    从远程仓库下载到本地
>
> `git checkout`  创建切换分支
>
> 解决git分支冲突： 将本地dev删除,在重新`checkout`一个`dev`分支(保证了此时我们的本地dev分支是最新的),在进行`pull`服务器分支,就这样解决了.
>
> 下载一个文件不是整个文件的解决方法：当`pull`的时候，后面直接带hash版本就可以下载对应的上传文件版本。

## node.js

### ~~1 - sessionStorage 在两个 tab 窗口能共享吗？如何解决？~~

>	不能sessionStorage在不同页面上不是同步共享的，和后端的 `session` 类似，每一个窗口对应一个会话层。
>	
>	解决：
>	
>	我们可以借用`localStorage`的改变来主动修改`sessionStorage`,这里要用到一个监听事件`storage`，用于监听`localStorage`
>	
>	```js
>	window.addEventListener("storage", function(event){
>	//event.key确认修改的locaStorage变化key，event.newValue是修改后的值
>	  if(event.key == "token"){
>	    sessionStorage.setItem('token',event.newValue)
>	  }
>	});
>	```
>	
>	在登陆时直接localStorage.setItem('token','xxxxx'),这样自动设置在了sessionStorage中，需要用到的时候直接sessionStorage.getItem('token'),其实直接使用localStorage来记录登录状态什么的也可以，但是为了关闭页面直接清楚token，所以就在写sessionStorage中了
>

### ~~2 - localStorage 存放的只能是 string 类型~~

>`localStorage`存储数据的格式都是以字符串的形式来存储的，
>
>存储数组对象的方式就是将数组对象转为字符串，在读取的时候再将字符串转成数组对象
>
>操作的方式：
>
>```js
>存：
>  var obj = {"name":"xiaoming","age":"16"}
>  localStorage.setItem("key",JSON.stringify(obj));
>取：
>  var user = JSON.parse(localStorage.getItem("key"))
>删除：
>  localStorage.remove("key");
>清空：
>
>localStorage.clear()
>```
>
>

### ~~3 - 项目中的中间层Node 在处理什么问题？~~
    使用node作为中间层，就相当于前端和传统的java/php服务端增加了一个隔层，那么很明显，这么看是提高开发成本且对性能有削弱的感觉，毕竟多一次交互，但你看看中间层到底能做什么，以至于为什么我们需要去用它：
    
    ● 接受客户端（浏览器）请求，向后端请求数据，接收后端返回的数据，返回给客户端
    ● 合并接口请求
    ● 拆分大接口
    ● 页面渲染
    ● 定义的路由
    ● 做数据缓存


​    

### 4 - NodeJS非阻塞I/O模型执行流程（事件循环）

>主线程：
>1. 执行 `node` 的代码，把代码放入队列
>2. 事件循环程序（主线程）把队列里面的同步代码都先执行了，
>3. 同步代码执行完成，执行异步代码
>4. 异步代码分 2种状况，
> (1)、异步非 `io setTimeout() setInterval()`
>判断是否可执行，如果可以执行就执行，不可以跳过。
>(2)、异步`io` 文件操作
>会从线程池当中去取一条线程，帮助主线程去执行。
>5. 主线程会一直轮训，队列中没有代码了，主线程就会退出。
>子线程：被放在线程池里面的线程，用来执行异步 `io`操作
>1. 在线程池里休息
>2. 异步 `io` 的操作来了，执行异步 `io`操作。
>3. 子线程会把异步 `io`操作的 `callback` 函数，扔回给队列
>4. 子线程会回到线程池了去休息。
>`callback`，在异步 `io` 代码执行完成的时候被扔回主线程。

### 5.如何判断当前脚本运行在浏览器还是node环境中？

> ```js
> Exports = typeof  window === 'undefined'? global: window ;
> ```
>
> 获取全局对象的方式
>
> 同理可得，`typeof window`可以用来判断是不是在浏览器环境中

## jQuery

### 1.谈谈你对`jQuery`的理解？

>- `JQuery` 是继 `prototype` 之后又一个优秀的 `Javascript` 库。它是轻量级的js 库 ，它
>
>兼容 CSS3，还兼容各种浏览器（IE 6.0+，FF1.5+，Safari 2.0+，Opera 9.0+），jQuery2.0
>
>及后续版本将不再支持 IE6/7/8 浏览器。`jQuery` 使用户能更方便地处理 HTML（标准通用
>
>标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供 AJAX 交互。
>
>- `jQuery`还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，
>
>同时还有许多成熟的插件可供选择。`jQuery` 能够使用户的 `html`页面保持代码和 `html` 内容
>
>分离，也就是说，不用再在 `html`里面插入一堆 `js` 来调用命令了，只需要定义 id即可。
>
>- `jQuery` 是一个兼容多浏览器的 `javascript` 库，核心理念是write less，do more(写
>
>得更少，做得更多)。 `jQuery`是免费、开源的，使用 MIT 许可协议。`jQuery` 的语法设
>
>计可以使开发更加便捷，例如操作文档对象、选择 `DOM` 元素、制作动画效果、事件处理、
>
>使用 `Ajax` 以及其他功能。除此以外，`jQuery` 提供 API让开发者编写插件。其模块化的使
>
>用方式使开发者可以很轻松的开发出功能强大的静态或动态网页。



### 2.原生JS的`window.onload`与Jquery的`$(document).ready(function() {})，$(function () {})`有什么不同？

>1.执行时间 `window.onload`必须等到页面内包括图片的所有元素加载完毕后才能执行。 `$(document).ready()`是 DOM 结构绘制完毕后就执行，不必等到加载完毕。
>
>2.编写个数不同 `window.onload`不能同时编写多个，如果有多个 `window.onload` 方法，只会执 行一个 `$(document).ready()`可以同时编写多个，并且都可以得到执行
>
>3.简化写法 `window.onload`没有简化写法
>
>```js
>$(document).ready(function (){})
>
>可以简写成$(function(){})；
>```

### 3.举一下jquery中的函数，这些函数实现链式编程的原理？

>```js
>toggle（fn, fn）
>$（“td”）.toggle（
>function（）{
>$（this）.addClass（“selected”）;
>}，
>function（）{
>$（this）.removeClass（“selected”）;
>）
>```
>
>实现函数链式编程的原理：返回自身，其他过程在函数内部实现，其好处是：节约js代码，返回的是同一个对象，提高代码的效率。





## Vue

### 1.vue是怎么传值的

>答：父子之间的传值
>
>父组件向子组件传值 通过prop 子组件在props中创建一个属性，用以接收父组件传过来的值 ，子组件向父组件传值 在响应该点击事件的函数中使用$emit来触发一个自定义事件 在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听
>
>  非父子之间的通讯
>
>可以通过eventBus来实现通信， 所谓eventBus就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件，ventBus = new Vue();
>
>组件1触发：
>
>~~~js
><div @click="eve"></div>
>methods: {
>    eve() {
>        eventBus.$emit('change','hehe'); //Hub触发事件
>    }
>}123456
>~~~
>
>组件2触发：
>
>~~~js
><div></div>
>created() {
>    eventBus.$on('change', () => { //Hub接收事件
>        this.msg = 'hehe';
>    });
>}123456
>~~~
>
>这样就实现了非父子组件之间的通信了.原理就是把eventBus当作一个中转站！

### 2.vue常用的修饰符

>a、按键修饰符
>
>如：.delete（捕获“删除”和”退格“键）   用法上和事件修饰符一样，挂载在v-on:后面，语法：`v-on:keyup.xxx=’yyy’ ```
>
>b、系统修饰符
>
>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器
>
>- .ctrl
>- .alt
>- .shift
>- .meta
>
>c、鼠标按钮修饰符
>
>- .left
>- .right
>- .middle
>  这些修饰符会限制处理函数仅响应特定的鼠标按钮。如：`A `鼠标滚轮单击触发  *Click默认是鼠标左键单击*
>
>```
>d、其他修饰符
>```
>
>- .lazy
>  在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 ，我们可以添加 `lazy` 修饰符，从而转变为使用 `change`事件进行同步：
>
>```
><!-- 在“change”时而非“input”时更新 -->
><input v-model.lazy="msg" >
>```
>
>- .number
>  如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `.number`修饰符：
>
>```
><input v-model.number="age" type="number">
>```
>
>这通常很有用，因为即使在`type="number"`时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 `parseFloat()`解析，则会返回原始的值。
>
>- .trim
>  如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：
>
>```
><input v-model.trim="msg">
>```
>
> 
>
>![img](https://upload-images.jianshu.io/upload_images/8915032-81d6c83fc5902163.png)
>
> 
>
>同样前面都有空格加上.trim后 将前后空格都去掉了

### 3. Vue.js特点

>简洁：页面由HTML模板+Json数据+Vue实例组成数据驱动：自动计算属性和追踪依赖的模板表达式组件化：用可复用、解耦的组件来构造页面轻量：代码量小，不依赖其他库快速：精确有效批量DOM更新模板友好：可通过npm，bower等多种方式安装，很容易融入

### 4.什么是vue全家桶

>Vue + vue-router + vuex + axios + es6 + sass



### 5.VUE是什么?

>vue.js（读音 /vjuː/，类似于 view） 是一套构建用户界面的渐进式框架与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。

### 6.React 和 Vue 的区别React 和 Vue 的相似之处

>1. 使用 Virtual DOM
>2. 提供了响应式（Reactive）和组件化（Composable）的视图组件。
>3. 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。 
>
>Vue与Angular、React的对比：
>1. vue.js 更轻量，gzip后只有20K+，angular:56K ,react:44K
>2. vue.js 更易上手，学习曲线平稳
>3. 吸收两家之长，有angular 的指令和 react组件化思想
>
>优缺点：
>
>优点：体积小。接口灵活。侵入性好，可用于页面的一部分，而不是整个页面。扩展性好。源码规范简洁。代码较为活跃，作者是中国人，可在官方论坛中文提问。github9000+。基于组件化的开发。它是一个轻量级 mvvm框架、数据驱动+组件化的前端开发、社区完善
>
>缺点：社区不大，如果有问题可以读源码。功能仅限于view 层，Ajax等功能需要额外的库。对开发人员要求较高。开发的话，需要 webpack，不然很难用，最好配合es6。

### .v-show 和 v-if的选择

>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。
>
>相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。

### 8.Vue.js核心思想

>Vue.js是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：数据驱动、组件系统。
>
>数据驱动：
>
>Vue.js数据观测原理在技术实现上，利用的是ES5Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。
>
>组件式编程

### 9.template参数选项的有无对生命周期的影响

>1. 如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数
>2. 如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高
>
>3. 如果1,2条件都不具备，则报错

### 10.怎么定义vue-router的动态路由？怎么获取传过来的动态参数？

>对path属性加上/:id。  使用router对象的params.id

### 11.vue-router有哪几种导航钩子

> vue-router 提供的导航钩子主要用来拦截导航，让它完成跳转或取消
>
>三种：
>
>第一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
>
>第二种：组件内的钩子；
>
>第三种：单独路由独享组件

### 12.说出至少4种vue当中的指令和它的用法？

>v-if：判断是否隐藏；
>
>v-for：数据循环出来；
>
>v-bind:class：绑定一个属性；
>
>v-model：实现双向绑定

### 13.简述一些vue项目中文件构成？

>build文件夹：主要就是webpack的配置；
>
>Config文件夹：主要的就是index.js 这个文件进行配置代理服务器
>
>Src文件夹：
>
> “assets”共用的样式和图片
>
> “components”业务代码存放
>
> “router”路由
>
> “APP.vue”vue 文件入口界面
>
> “main.js”对应App.vue创建的实例，也是入口文件，对应   webpack.base.config.js里的入口配置
>
>Static文件夹：静态资源
>
>Pack.json:scripts 里面设置命令，例如设置了dev用于调试则我们开发时输入的是npm run dev ；例如设置了build 则是输入 npm run build 用于打包;另一部分是这里可以看到我们需要的依赖包,在dependencies和devDependencies中，分别对应全局下载和局部下载的依赖包

### 14.vue中 `key` 值的作用

>使用key来给每个节点做一个唯一标识
>
>**key的作用主要是为了高效的更新虚拟DOM**。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，
>
>否则vue只会替换其内部属性而不会触发过渡效果。

### 15.Vue 组件中 data 为什么必须是函数

>在 `new Vue()` 中，`data` 是可以作为一个对象进行操作的，然而在 `component` 中，`data` 只能以函数的形式存在，不能直接将对象赋值给它。
>
>当data选项是一个函数的时候，每个实例可以维护一份被返回对象的独立的拷贝，这样各个实例中的data不会相互影响，是独立的

### 16.vue中子组件调用父组件的方法

>第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法
>
>第二种方法是在子组件里用`$emit`向父组件触发一个事件，父组件监听这个事件就行了。
>
>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法

### 17.vue生命周期钩子函数有哪些？

>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。
>
>　　创建前/后
>
>　　在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。
>
>　　在created阶段，vue实例的数据对象data有了，$el还没有。
>
>　　载入前/后
>
>　　在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。
>
>　　在mounted阶段，vue实例挂载完成，data.message成功渲染。
>
>　　更新前/后
>
>　　当data变化时，会触发beforeUpdate和updated方法。
>
>　　销毁前/后
>
>　　在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

### 18.说出至少 4 种 vue 当中的指令和它的用法

>v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定)

### 19.vue 的双向绑定的原理是什么

>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。



## Vue进阶

### 1.什么是MVVM？

>MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。
>
>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
>
>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。
>

### 2.mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？

>mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
>
>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。
>
>场景：数据操作比较多的场景，更加便捷
>

### 3.vue如何实现按需加载配合webpack设置

>webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。
>
>不进行页面按需加载引入方式：`import home from ‘…/…/common/home.vue’`
>
>进行页面按需加载的引入方式：`const home = r => require.ensure( [], () => r (require(’…/…/common/home.vue’)))`
>

### 4.生命周期相关

>1）、什么是vue生命周期
>
>答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。
>
>（2）、vue生命周期的作用是什么
>
>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。
>
>（3）、vue生命周期总共有几个阶段
>
>答：可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后
>
>（4）、第一次页面加载会触发哪几个钩子
>
>答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子
>
>（5）、DOM 渲染在 哪个周期中就已经完成
>
>答：DOM 渲染在 mounted 中就已经完成了。
>
>（6）、简单描述每个周期具体适合哪些场景
>
>答：生命周期钩子的一些使用方法：
>
>beforecreate : 可以在这加个loading事件，在加载实例时触发
>
>created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
>
>mounted : 挂载元素，获取到DOM节点
>
>updated : 如果对数据统一处理，在这里写上相应函数
>
>beforeDestroy : 可以做一个确认停止事件的确认框
>
>nextTick : 更新数据后立即操作dom
>
